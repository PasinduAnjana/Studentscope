<style>
/* Copy styles from teacher marks entry if not global, or use same classes */
.marks-input {
    width: 60px;
    text-align: center;
    padding: 4px;
    border: 1px solid var(--color-border);
    border-radius: 4px;
}
</style>

<section class="section">
    <div class="flex-between mb-2">
      <button class="btn btn-secondary" onclick="window.history.back()">
          <i class="fas fa-arrow-left"></i> Back
      </button>
      <h2 class="heading">
        <i class="fas fa-edit"></i>
        <span>Enter Marks</span>
      </h2>
    </div>

    <!-- Match Teacher UI Structure -->
    <div class="card">
        <div class="marks-entry">
            <div class="marks-entry-header" style="margin-bottom: 20px;">
                <h3 id="exam-details">Loading Exam...</h3>
            </div>

            <div class="marks-table-container" style="overflow-x: auto;">
                <table class="marks-table" id="custom-marks-table" style="width: 100%; border-collapse: collapse;">
                    <!-- Headers and rows generated by JS -->
                </table>
            </div>

            <div class="action-buttons" style="margin-top: 20px; display: flex; justify-content: flex-end;">
                <button class="btn btn-primary" onclick="saveMarks()">
                    Submit
                </button>
            </div>
        </div>
    </div>
</section>

<script>
    const urlParams = new URLSearchParams(window.location.search);
    const examId = urlParams.get('examId');
    let currentMarks = {}; 

    function init() {
        if (!examId) {
            toast("Exam ID missing", "fa-solid fa-circle-exclamation");
            return;
        }

        fetchExamDetails().then(exam => {
            if (exam) {
                fetchSubjectsAndStudents(exam);
            }
        });
    }

    function fetchExamDetails() {
        return api.clerk.exams.getAll()
        .then(res => res.json())
        .then(exams => {
            const exam = exams.find(e => e.id == examId);
            if (exam) {
                document.getElementById("exam-details").textContent = `${exam.name} (${exam.year}) - ${exam.target_grade || 'All Grades'}`;
                return exam;
            }
            return null;
        });
    }

    function fetchSubjectsAndStudents(exam) {
        Promise.all([
            api.request("/clerk/subjects").then(res => res.json()),
            api.clerk.exams.getStudents(examId).then(res => res.json()),
            api.clerk.exams.getMarks(examId).then(res => res.json())
        ]).then(([allSubjects, students, marks]) => {
            // Populate currentMarks
            if (Array.isArray(marks)) {
                marks.forEach(m => {
                    const key = `${m.student_id}_${m.subject_id}`;
                    currentMarks[key] = m.marks;
                });
            }

            const filteredSubjects = filterSubjectsForExam(allSubjects, exam);
            renderMatrixTable(filteredSubjects, students, exam);
        });
    }

    function filterSubjectsForExam(allSubjects, exam) {
        let subjects = [];
        const grade = exam.target_grade;
        const subType = exam.sub_type || '';

        if (grade == 5 || subType.includes('scholarship')) {
            // Grade 5 Scholarship
            // Look for a subject named "Scholarship" or similar, or just allow one column
            // If we can't find exact ID, we might have issue saving.
            // Let's attempt to find "Scholarship" or "Grade 5".
            const scholarshipSub = allSubjects.find(s => s.subject_name.toLowerCase().includes('scholarship') || s.subject_name.includes('Grade 5'));
            if (scholarshipSub) {
                subjects = [scholarshipSub];
            } else {
                // Fallback: Use one column, maybe with forced ID if we knew it?
                // Visual only:
                subjects = [{ subject_id: null, subject_name: 'Scholarship Marks (200)' }];
            }
        } else if (grade == 10 || grade == 11 || subType === 'ol') {
            // O Level
            // Mandatory: Religion, Sinhala/Language, English, Mathematics, History, Science
            // Buckets: Business, Music, Art, ICT, etc.
            // Strategy: Include Core subjects explicitly, then add others that are typically Grade 10/11
            
            const mandatoryKeywords = ['Religion', 'Sinhala', 'Tamil', 'English', 'Mathematic', 'History', 'Science'];
            const core = allSubjects.filter(s => mandatoryKeywords.some(k => s.subject_name.includes(k)));
            
            // Bucket subjects (Electives) - assuming they are recognizable or we just add rest
            // Simpler approach: Filter all subjects available for Grade 10-11 if DB has that info? 
            // DB schema for subjects likely doesn't have grade.
            // Let's add commonly known electives: Commerce, Art, Music, Dancing, ICT, Literature, Geography, Civic
            const electiveKeywords = ['Business', 'Commerce', 'Art', 'Music', 'Danc', 'ICT', 'Lit', 'Geo', 'Civic', 'Health', 'Media'];
            const electives = allSubjects.filter(s => electiveKeywords.some(k => s.subject_name.includes(k)) && !core.includes(s));
            
            subjects = [...core, ...electives];
            
        } else if (grade == 12 || grade == 13 || subType === 'al') {
            // A Level
            // Show A-Level subjects: Physics, Chem, Bio, Combined Maths, Econ, Acc, Arts, Tech
            // Filter by keywords logic
            const alKeywords = ['Physics', 'Chemistry', 'Biology', 'Combined', 'Agri', 'Econ', 'Account', 'Logic', 'Politic', 'Media', 'Tech', 'Art', 'Geog', 'Civil'];
            subjects = allSubjects.filter(s => alKeywords.some(k => s.subject_name.includes(k)));
        } else {
            // Default: Show all or maybe filtered by grade if feasible
            subjects = allSubjects;
        }
        
        // Remove duplicates and sort
        subjects = [...new Set(subjects)].sort((a,b) => a.subject_name.localeCompare(b.subject_name));
        return subjects;
    }

    function renderMatrixTable(subjects, students) {
        const table = document.getElementById("custom-marks-table");
        table.innerHTML = "";

        // Header Row
        const thead = document.createElement("thead");
        const headerRow = document.createElement("tr");
        headerRow.innerHTML = `
            <th style="padding: 10px; background: var(--color-bg); text-align: left;">Student Name</th>
            <th style="padding: 10px; background: var(--color-bg); text-align: left;">Index</th>
            ${subjects.map(s => `<th style="padding: 10px; background: var(--color-bg); text-align: center;">${s.subject_code || s.subject_name.substring(0, 3)}</th>`).join("")}
        `;
        thead.appendChild(headerRow);
        table.appendChild(thead);

        // Body
        const tbody = document.createElement("tbody");
        
        students.forEach(student => {
            const row = document.createElement("tr");
            row.style.borderBottom = "1px solid var(--color-border)";
            
            // Generate cells
            let cells = `
                <td style="padding: 10px;">${student.full_name}</td>
                <td style="padding: 10px;">${student.index_number || '-'}</td>
            `;
            
            subjects.forEach(sub => {
                const val = currentMarks[`${student.student_id}_${sub.subject_id}`] || "";
                cells += `
                    <td style="padding: 5px; text-align: center;">
                        <input type="text" class="mark-input" 
                            title="${sub.subject_name}"
                            value="${val}"
                            onchange="markChanged(${student.student_id}, ${sub.subject_id}, this.value)">
                    </td>
                `;
            });
            
            row.innerHTML = cells;
            tbody.appendChild(row);
        });
        
        table.appendChild(tbody);
        
        // Add navigation logic similar to teacher dashboard
        enableArrowNavigation(table);
    }

    function markChanged(studentId, subjectId, val) {
        currentMarks[`${studentId}_${subjectId}`] = val;
    }

    function saveMarks() {
         const marksData = [];
        for (const [key, val] of Object.entries(currentMarks)) {
            let [sid, subId] = key.split('_');
            if (subId === 'null') subId = null;
            
            marksData.push({
                student_id: sid,
                subject_id: subId,
                marks: val
            });
        }
        
        if (marksData.length === 0) {
            toast("No changes to save", "fa-solid fa-info-circle");
            return;
        }
        
        api.clerk.exams.saveMarks(examId, marksData)
        .then(res => {
             if(!res.ok) throw new Error("Failed");
             toast("Marks saved", "fa-solid fa-check-circle");
             // currentMarks = {}; // Optional clear
        })
        .catch(err => toast("Error saving", "fa-solid fa-circle-exclamation"));
    }

    function enableArrowNavigation(table) {
        // Simple arrow navigation implementation
        table.addEventListener("keydown", (e) => {
            if (!e.target.classList.contains("mark-input")) return;
            if (!["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) return;
            
            e.preventDefault();
            const input = e.target;
            const td = input.closest("td");
            const tr = td.closest("tr");
            const inputs = Array.from(tr.querySelectorAll(".mark-input"));
            const colIndex = inputs.indexOf(input);
            const trs = Array.from(table.querySelectorAll("tbody tr"));
            const rowIndex = trs.indexOf(tr);
            
            let nextInput;
            
            if (e.key === "ArrowRight") {
                if (colIndex < inputs.length - 1) nextInput = inputs[colIndex + 1];
            } else if (e.key === "ArrowLeft") {
                if (colIndex > 0) nextInput = inputs[colIndex - 1];
            } else if (e.key === "ArrowDown") {
                if (rowIndex < trs.length - 1) {
                    const nextRowInputs = trs[rowIndex + 1].querySelectorAll(".mark-input");
                    nextInput = nextRowInputs[colIndex];
                }
            } else if (e.key === "ArrowUp") {
                if (rowIndex > 0) {
                    const prevRowInputs = trs[rowIndex - 1].querySelectorAll(".mark-input");
                    nextInput = prevRowInputs[colIndex];
                }
            }
            
            if (nextInput) {
                nextInput.focus();
                nextInput.select();
            }
        });
    }

    init();
</script>
